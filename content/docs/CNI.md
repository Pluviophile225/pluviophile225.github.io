

# CNI

## Lab 环境搭建

![image-20230131191746476](../assets/image-20230131191746476.png)

```markdown
* 红色的是K8S集群的默认网络
		有四个节点，master1，worker1、2、3
		其中master1、worker1、worker2在机架1上 他们在同一网段10.0.0.0/24 网关在leaf01上
		worker3在另一个机架，网段在30.0.0.0/24 网关在leaf02上
		leafSpine架构，spine接到一个net的网段，连接到笔记本就可以出去了
* 绿色的是网管的网络，三个交换机+四个主机
* 虚线是用来做网络协议栈的lab demo
```

> 全局设定中设置网络

![image-20230201154503379](../assets/image-20230201154503379.png)

> 主机网络管理

![image-20230201154755836](../assets/image-20230201154755836.png)

> 各个主机连接

### master1

```markdown
* 红色接#2 10.0.0.1/24
* 绿色接#1 192.168.100.1/24
* 虚线接#6 192.168.210.1/24
```

### worker1

```markdown
* 红色接#2 10.0.0.1/24
* 绿色接#1 192.168.100.1/24
* 虚线接#6 192.168.210.1/24
```

### worker2

```markdown
* 红色接#2 10.0.0.1/24
* 绿色接#1 192.168.100.1/24
* 虚线接#6 192.168.210.1/24
```

### worker3

```markdown
* 红色接#3 30.0.0.1/24
* 绿色接#1 192.168.100.1/24
* 虚线接#7 192.168.230.1/24
```

### Leaf01

```markdown
* 红色接#2 10.0.0.1/24
* 绿色接#1 192.168.100.1/24
* 与Spine接#4 50.0.0.1/24
```

### Leaf02

```markdown
* 红色接#3 10.0.0.1/24
* 绿色接#1 192.168.100.1/24
* 与Spine接#5 60.0.0.1/24
```

### Spine

```markdown
* 与笔记本接k8sNAT 192.168.8.0/24
* 与Leaf02接#5 60.0.0.1/24
* 与Leaf01接#4 50.0.0.1/24
* 接#1 192.168.100.0？24
```

## 前置知识

```markdown
* Network protocol stack(MAC/ARP/IP/ICMP/TCP/UDP)
* Bridging/Switching(VLAN/VxLAN) and Routing(subnet/netmask, gateway/nexthop, route lookup)
* Linux commands(ip, iptables, conntrack, …)
* Container/Linux namespaces(Network, Mount, UTS, IPC, User)
* Kubernetes installation and operation
```

### MAC协议栈

MAC（multiple access control protocol）多路访问控制协议。这个协议用在数据链路层中。

```markdown
* 介质访问控制
	* 静态划分信道
		* 信道划分介质访问控制
			* 频分多路复用FDM
			* 时分多路复用TDM
			* 波分多路复用WDM
			* 码分多路复用CDM
	* 动态划分信道
		* 轮询访问介质访问控制
			* 令牌传递协议
		* 随机访问介质访问控制
			* Aloha协议
			* CSMA协议
			* CSMA/CD 协议
			* CSMA/CA 协议
```

#### 信道划分MAC协议

##### 时分多路复用 TDMA：time division multiple access

![image-20230203174705700](../assets/image-20230203174705700.png)

周期性地接入信道，每个站点在每个周期，占用固定长度的时隙。数据少的时候，信道的利用率不高，只有数据多的情况下，数据的利用率比较高。

##### 频分多路复用 FDMA：frequency division multiple access

![image-20230203175018620](../assets/image-20230203175018620.png)



频分多路复用是指载波带宽被划分为多种不同频带的子信道，每个子信道可以并行传送一路信号的一种多路复用技术。

#### 随机访问MAC协议

随机访问MAC协议需要定义：

1. 如何检测冲突
2. 如何从冲突中恢复（通过延迟重传）

##### 时隙Aloha协议

思想：把时间划分成若干相同的时间片，所有用户在时间片开始时刻同步接入网络通道，若发生冲突，则必须等到下一个时间片开始时刻传送。

![image-20230207020326326](../assets/image-20230207020326326.png)

假定所有帧大小相同，时间被划分为等长的时隙（每个时隙可以传输1个帧），节点只能在时隙开始时刻发送帧，节点间时钟同步，如果2个或2个以上节点在同一时隙发送帧，节点即检测到冲突，当节点有新的帧时，在下一个时隙发送，若无冲突，该节点可以在下一个时隙继续发送新的帧，如果有冲突，该节点在下一个时隙以概率p重传该帧，直到成功。

```markdown
优点：
* 单个节点活动时，可以连续以信道全部速率传输数据
* 高度分散化：只需同步时隙
* 简单
缺点：
* 冲突、浪费时隙
* 空闲时隙
* 节点也许能以远小于分组传输时间检测到冲突
* 时钟同步
```

##### Aloha协议

思想：不监听信道，不按时间槽发送，随机发送，当有新的帧生成时，立即发送冲突可能性增大吗，在t0时刻发送帧，会与在[t0 - 1,t0 + 1]期间其他节点发送的帧冲突。

![image-20230207020330575](../assets/image-20230207020330575.png)

##### CSMA协议

Carrier Sense Multiple Access（CSMA），是一种允许多个设备在同一信道发送信号的协议，其中的设备监听其他设备是否忙碌，只有在线路空闲时才发送。

思想：发送帧之前，监听信道

```markdown
监听结果：
* 信道空闲：发送完整帧
* 信道忙：推迟发送
```

- 1-坚持CSMA

  如果一个主机想要发送信息，那必须要监听信道，若信道不忙，则发送数据；若信道忙，则一直监听，直到信道空闲就马上传输

- 非坚持CSMA

  如果一个主机想要发送信息，那必须要监听信道，若信道不忙，则发送数据；若信道忙，则放弃监听，等待一个随机时间再监听

- p-坚持CSMA

  如果一个主机想要发送信息，那必须要监听信道，若信道不忙，则以p的概率发送数据；若信道忙，等待一个随机的时间后再次监听

##### CSMA/CD协议

短时间内可以检测到冲突，冲突后传输中止，减少信道浪费（边发送边监听）

```markdown
冲突检测：
有线局域网易于实现：测量信号强度，比较发射信号与接受信号
无线局域网很难实现：接受信号强度淹没在本地发射信号强度下
```

若想检测冲突，并停止发送，需满足L / R ≥ 2dmax / V

此方案应用于以太网（DIX Ethernet V2）标准，IEEE 802.3标准

##### CSMA/CA协议

CSMA/CA协议主要使用两种方法来避免碰撞：

1. 设备欲发送帧，且监听到信道空闲时，维持一段时间后，再等待一段随机的时间依然空闲时，才送出信息。由于各个设备的等待时间是分别随机产生的，因此很大可能有所区别，由此可以减少冲突的可能性。
2. RTS-CTS握手（handshake）设备欲发送帧前，先发送一个很小的RTS（Request to Send）帧给目标端，等待目标端回应CTS（Clear to Send）帧后，才开始传送。此方式可以确保接下来传送信息时，不会发生冲突。同时由于RTS帧和CTS帧都很小，让传送的无效开销变小。

此方案应用于无线局域网IEEE 802.11标准

#### 轮转访问MAC协议

```markdown
信道划分MAC协议：
1、网络负载重时，共享信道效率高，且公平
2、网络负载轻时，共享信道效率低

随机访问MAC协议：
1、网络负载轻时，共享信道效率高，单个节点可以利用信道的全部带宽
2、网络负载重时，产生冲突开销

轮转访问MAC协议：
既要不产生冲突，又要发送时占全部带宽（综合两者优点）

轮询访问控制的特点：在轮询访问中，用户不能随机地发送信息，而要通过一个集中控制的监控站，以循环方式轮询每个节点，再决定信道的分配。当某节点使用信道时，其他节点都不能使用信道，主要分为轮询协议与令牌传递协议
```

##### 轮询（polling）协议

轮询协议要求节点中有一个被指定为主节点，其余节点是从属节点，主节点以循环的方式轮询每一个从属节点，“邀请”从属节点发送数据（实际上是向从属节点发送一个报文，告诉从属节点可以发送帧以及可以传输帧的最大数量），只有被主节点“邀请”的从节点可以发送数据，没有被“邀请”的节点不能发送，只能等待被轮询。

![image-20230207020338393](../assets/image-20230207020338393.png)

##### 令牌传递（token passing）协议

控制令牌（特殊帧）依次从一个节点传递到下一个节点。令牌由专用的信息块组成，典型的令牌由连续的8位“1”组成。当网络所有节点都空闲时，令牌就从一个节点传送到下一个节点，当某一节点要求发送信息时，它必须获得令牌并在发送之前把他从网络上取走，一旦传送完数据，就把令牌转送给下一个节点，每个几点都具备有发送/接受令牌的装置。

使用这种传送方式绝不会发生碰撞，在某一瞬间只有一个节点有可能传送数据，最大的问题是令牌在传送过程中丢失或受到破坏，从而使节点找不到令牌从而无法传送信息。

### ARP协议栈

#### MAC地址

MAC地址：Media Access Control Address，媒体访问控制地址。MAC地址也称为物理地址，硬件地址和老化地址。

![image-20230207020342967](../assets/image-20230207020342967.png)

![image-20230206182321005](../assets/image-20230206182321005.png)

##### 组成及转发原理

```markdown
* MAC地址表记录设备学习到的其他设备的MAC地址与接口的对应关系，以及接口所属VLAN等信息。
* MAC地址表用于指导报文进行单播转发，设备在转发报文时，根据报文的目的MAC地址查询MAC地址表：
	如果MAC地址表中包含与报文目的MAC对应的表项，则直接通过该表项的出接口转发该报文。
	如果MAC地址表中没有包含报文目的MAC地址对应的表项时，设备将采取广播方式在所属VLAN内除接受接口外的所有接口转发该报文。		
```

##### 学习及老化

一般情况下，MAC地址表是设备根据收到的数据帧里的源MAC地址自动学习而建立的。

> 如果MAC地址表中不存在该MAC地址表项，设备则将这个新MAC地址以及该MAC地址对应的Port和VLAN ID作为一个新的表项加入到MAC地址表中。

> 如果MAC地址表中已经存在该MAC地址表项，设备将通过重置该表项的老化时间，对该表项进行更新。

设备只有在收到数据帧时，才会触发MAC地址的学习和刷新。

设备所有接口默认加入VLAN1，如果不做修改所有MAC地址表项的VLAN ID都是VLAN1。

设备对于BPDU MAC（形如：0180-c200-xxxx）不会进行MAC地址学习。

为适应网络的变化，MAC表需要不断更新。MAC表中自动生成的表项（即动态表项）并非永久有效，每一条表项都有一个生存周期，到达生存周期仍得不到更新的表项将被删除，这个生存周期被称作老化时间，默认300S。如果在到达生存周期前记录被更新，则该表项的老化时间重新计算。

##### MAC地址表项

由接口通过报文中的源MAC地址学习获得，表项可老化。

在系统复位、接口板热插拔或接口复位后，动态表项会丢失。

通过查看动态MAC地址表项，可以判断两台相连设备之间是否有数据转发。

通过查看指定动态MAC表项的个数，可以获取接口下通信的用户数。

##### 静态表项

由用户手工配置，并下发到各接口板，表项不可老化。

在系统复位、接口板热插拔或接口板复位后，保存的表项不会丢失。

接口和MAC地址静态绑定后，其他接口收到源MAC是该MAC地址的报文将被丢弃。

一个静态MAC地址表项，只能绑定一个出接口。

一个接口和MAC地址静态绑定后，不会影响该接口动态MAC地址表项的学习。

通过绑定静态MAC地址表项，可以保证合法用户的使用，防止其他用户使用该MAC进行攻击。

##### 黑洞表项

由用户手工配置，并下发到各接口板，表项不可老化。

在系统复位、接口板热插拔或接口板复位后，保存的表项不会丢失。

配置黑洞MAC地址后，源MAC地址或目的MAC地址是该MAC的报文将会被丢弃。

通过配置黑洞MAC地址表项，可以过滤掉非法用户。

#### ARP是什么

ARP协议的全称是Address Resolution Protocol（地址解析协议），它是一个通过用于实现从IP地址到MAC地址的映射，即询问目标IP对应的MAC地址的一种协议。ARP协议在IPv4中极其重要。

- ARP只用于IPv4协议中，IPv6协议使用的是Neighbor Discovery Protocol，即邻居发现协议，它被纳入ICMPv6中。
- ARP是一种解决地址问题的协议，它以IP地址为线索，定位下一个应该接收数据分包的主机MAC地址。如果目标主机不在同一个链路上，那么会查找下一跳路由器的MAC地址。

#### ARP的工作机制

![image-20230207001927489](../assets/image-20230207001927489.png)

IP地址将物理层地址对上层隐藏起来，使Internet表现出统一的地址格式，但是在实际通讯时，IP地址不能被物理网络所识别，物理网络所使用的依然是物理地址。因此必须实现IP地址对物理地址的映射。

对于以太网而言，当IP数据包通过以太网发送时，以太网链路并不识别32位的IP地址，它们是以48位的MAC地址表示该以太网节点。因此，必须在IP地址与MAC地址之间建立映射关系（MAP），而建立这种映射的过程就是地址解析（Resoloution）。

1. HostA首先查看自己的ARP表项，确定其中是否包含HostB的IP地址对应ARP表项。如果找到了对应的表项，则HostA直接由ARP表项中的MAC地址对IP数据包封装成帧，并将帧发送给HostB。
2. 如果HostA在ARP表中找不到对应的表项，则暂时缓存该数据包，然后以广播方式发送一个ARP请求。ARP请求报文中的发送IP地址和发送端MAC地址为HostA的IP地址和MAC地址，目标IP地址HostB的IP地址，目标MAC地址为全0的MAC地址。
3. 由于ARP请求报文以广播方式发送，该网段上的所有主机都可以接收到该请求。HostB比较自己的IP地址和ARP请求报文中的目标IP地址，由于两者相同，HostB将ARP请求报文的发送端（HostA）IP地址和MAC地址存入自己的ARP表中，并以单播方式向HostA发送ARP响应，其中包含了自己的MAC地址。其他主机发现请求的IP地址并非自己，于是都不做应答。
4. HostA收到ARP响应报文后，将HostB的MAC地址加入到自己的ARP表中，同时将IP数据包用此MAC地址为目的地址封装成帧并发送给HostB。

> 如果是不同链路怎么办呢？

这就要使用到代理ARP了，通常ARP会被路由器隔离，但是采用代理ARP（ARP Proxy）的路由器可以将ARP请求转发给临近的网段。使多个网段中的节点像是在同一网段内通信。

#### ARP缓存

ARP高效运行的关键就算维护每个主机和路由器上的ARP缓存（表）。

这个缓存维护着每个IP到MAC地址的映射关系。通过把第一次ARP获取到的MAC地址作为IP对MAC的映射关系到一个ARP缓存表中，下一次再向这个地址发送数据报时就不再需要重新发送ARP请求了，而是直接使用这个缓存表中的MAC地址进行数据报的发送。每发送一次ARP请求，缓存表中对应的映射关系都会被清除。

通过ARP缓存，降低了网络流量的使用，在一定程度上防止了ARP的大量广播。

![image-20230207141852352](../assets/image-20230207141852352.png)

一般来说，发送过一次APR请求后，再次发送相同请求的几率比较大，因此使用ARP缓存能够减少ARP包的发送，除此之外，不仅仅ARP请求的发送方能够缓存ARP接收方的MAC地址，接收方也能够缓存ARP请求方的IP和MAC地址。

![image-20230207142044680](../assets/image-20230207142044680.png)

不过，MAC地址的缓存有一定期限，超过这个期限后，缓存的内容会被清除。

可以在Linux中使用`arp`命令查看ARP缓存。

![image-20230207142257715](../assets/image-20230207142257715.png)

> 主要包含五项

```markdown
* 主机名---对应一个IP地址
* 硬件地址类型
* 硬件地址
* 标志
* 本地网络接口
```

```markdown
** 标志主要分为三类：C、M或P，C表示的是由ARP协议动态学习。M类可以通过`arp -s`增加一条。P类表示的是发布，对于任何P类项目，主机对输入的APR请求都返回一个ARP响应。这个选项用于配置代理ARP。
```

![image-20230207142643509](../assets/image-20230207142643509.png)

Windows中ARP程序显示了IPv4的地址，它的接口是十六进制数，Windows版本还指出地址是手动输入还是ARP动态学习的。

#### ARP结构

![img](../assets/1620.png)

前面14个字节构成标准以太网的首部，前面两个字段DST和SRC分别表示以太网的目的地址和以太网的源地址，以太网的目的地址如果是`ff:ff:ff:ff:ff:ff`全部为1表示广播地址，在同一广播域中所有以太网接口可以接收这些帧。后面紧跟着的是ARP请求的长度/类型，ARP请求和ARP应答这个值为0x0806。

```markdown
* 硬件类型表示硬件地址的类型，硬件地址常见的有MAC物理地址或者以太网地址，对于以太网来说，此值为1。
* 协议类型指出映射的协议地址类型，对于IPv4地址，这个值是0x0800。
* 硬件大小和协议大小分别指出硬件地址和协议地址的字节数。对于以太网中使用IPv4的ARP请求或应答，它们的值分别是6和4。
* Op字段指出如果是ARP请求，ARP请求 Op = 1 ，ARP应答 Op = 2，RARP请求 Op = 3，RARP应答 Op = 4。
* 紧跟在Op之后的是发送方硬件地址（MAC地址），发送发的协议地址（IPv4地址），目的硬件地址和目的协议地址。
```

#### ARP缓存超时

1. ARP缓存

   ```markdown
   * ARP高效运行的关键是维护每个主机和路由器上的ARP缓存
   * 该缓存使用地址解析为每个接口维护从网络层地址到硬件地址的最新映射
   * IPv4地址映射到硬件地址时，它对应于高速缓存中的一个条目，其正常到期时间是条目创建开始后的20分钟
   ```

2. ARP缓存超时

   ```markdown
   * 超时通常与ARP缓存中的每个条目相关（arp命令允许管理员设置缓存条目永远不超时）
   * 在大多数实现中，完整条目的超时为20分钟，而不完整条目的超时为3分钟
   * 这些实现通常在每次使用一个条目后为它重新启动20分钟的超时。[RFC|122]是描述主机需求的RFC，它规定每个条目即使在使用也应启动超时，但很多实现并不这样做，它们在每次使用条目后重新启动超时
   ```

#### RARP

与ARP相对的，RARP（Reverse Address Resolution Protocol）是将ARP反过来，从MAC地址定位IP地址的一种协议，将打印机服务器等小型嵌入式设备接入网络时会使用到。

![image-20230207173405399](../assets/image-20230207173405399.png)



平常设置IP地址一般会有两种方式，手动设置和DHCP动态获取：

![image-20230207173448645](../assets/image-20230207173448645.png)

但是对于嵌入式设备来说，它没有任何输入接口，也无法通过DHCP获取动态地址。

在这种情况下，就要使用RARP了，需要准备一个RARP服务器，在这个服务器上注册设备的MAC地址和IP地址，然后将设备接入网络，设备会发出一条IP和MAC地址的查询请求给服务器，服务器会告诉设备其IP地址和MAC地址。

![image-20230207173917867](../assets/image-20230207173917867.png)

主机只知道自己的硬件地址时，可以通过RARP解析自己的IP地址，RARP常用于无盘工作站启动前获取自身的IP地址。

在刚刚启动时，无盘工作站只知道自己网卡的MAC地址，需要获取自己的IP地址，于是向网络中广播RARP请求。RARP服务器接收广播请求后发送应答报文，无盘工作站随即获得IP地址。

RARP服务器要响应请求，首先必须知道物理地址与IP地址的对应关系。为此，在RARP服务器维护着一个本网段的"物理地址-IP地址"映射表。当某无盘工作站发出RARP请求后，网上所有主机均收到该请求，但只有RARP服务器处理请求并根据请求这物理地址响应请求。无盘工作站发出RARP请求中携带其物理地址，服务器根据次硬件地址查找其IP地址。由于服务器此时已经知道无盘工作站的物理地址，因此不在采取广播方式，而是直接向无盘工作站发送单播应答。

对应于ARP、RARP请求以广播方式发送，ARP、RARP应答一般以单播方式发送，以节省网络资源。

#### ARP攻击

ARP是一种非常不安全的协议，目前已经有很多涉及ARP的攻击，最主要的就是使用代理ARP功能假扮主机，对ARP请求作出应答，通过伪造ARP数据包来窃取合法用户的通信数据，造成影响网络传输速率和盗取用户隐私信息等严重危害。

##### ARP攻击分类

- ARP泛洪攻击：通过向网关发送大量ARP报文，导致网关无法正常响应。首先发送大量的ARP请求报文，然后又发送大量虚假的ARP响应报文，从而造成网关部分的CPU利用率上升难以响应正常服务请求，而且网关还会被错误的ARP缓存表充满导致无法更新维护正常ARP缓存表，消耗网络带宽资源。
- ARP欺骗主机攻击：攻击者通过ARP欺骗使得局域网内被攻击主机发送给网关的流量信息实际上都发送给攻击者。主机刷新自己的ARP使得在自己的ARP缓存表中对应的MAC为攻击者的MAC，这样一来其他用户要通过网关发送出去的数据流就会发往主机这里，这样就会造成用户的数据外泄。
- 欺骗网关的攻击：欺骗网关就是把别的主机发送给网关的数据通过欺骗网关的形式使得这些数据通过网关发送给攻击者。这种攻击目标选择的不是个人主机而是局域网的网关，这样就会攻击者源源不断地获取局域网内其他用户源数据。造成数据的泄露，同时用户电脑中毒的概率也会提升。
- 中间人攻击：中间人攻击是同时欺骗局域网内的主机和网关，局域网中用户的数据和网关的数据会发给同一个攻击者，这样，用户与网关的数据就会泄露。
- IP地址冲突攻击：通过对局域网中的物理主机进行扫描，扫描出局域网中的物理主机的MAC地址，然后根据物理主机的MAC进行攻击，导致局域网内的主机产生IP地址冲突，影响用户的网络正常使用。

##### ARP攻击发现

首先判断是否为ARP病毒攻击

- 当发现上网明显变慢，或者突然掉线时，我们可以用`arp -a`命令来检查ARP表。如果发现网关的MAC地址发生了改变，或者发现有很多IP指向同一个物理地址，那么肯定就是ARP欺骗所致。这是可以通过`arp -d`清除arp列表，重新访问。
- 利用ARP防火墙类软件。

> 如何判断交换机是否受到ARP攻击以及处理方式

如果网络受到了ARP攻击，可能会出现如下现象：

- 用户掉线、频繁断网、上网慢、业务中断或无法上网。
- 设备CPU占用率较高、设备托管、下挂设备掉线、设备主备状态震荡、设备端口指示灯红色快闪。
- Ping有时延、丢包或不同

局域网内的机器遭到ARP病毒欺骗攻击，如果找到源头的机器，将其病毒或木马杀掉，局域网内机器就会恢复正常，那么如何才能快速定位到攻击的源头机器呢？

- 使用`arp -a`命令。当发现上网明显变慢，或者突然掉线时，我们可以用`arp -a`命令来检查ARP表。如果发现网关的MAC地址发生了改变，或者发现有很多IP地址指向同一个MAC地址，那么肯定就是ARP攻击所致。
- 利用ARP防火墙软件查看。
- 通过路由器的“系统历史记录”查看。由于ARP攻击的木马程序发作的时候会发出大量的数据包导致局域网通讯阻塞以及其自身处理能力的限制，用户会感觉上网速度越来越慢。当ARP攻击的木马程序停止运行时，用户会恢复从路由器上网，切换过程中用户会再断一次线。这个消息代表了用户的MAC地址发生了变化，在ARP攻击木马开始运行的时候，局域网所有主机的MAC地址更新为病毒主机的MAC地址(即所有信息的MAC New地址都一致为病毒主机的MAC地址)，同时在路由器的“用户统计”中看到所有用户的MAC地址信息都一样。

如果是在路由器的“系统历史记录”中看到大量MAC Old地址都一致，则说明局域网内曾经出现过ARP攻击(ARP攻击的木马程序停止运行时,主机在路由器上恢复其真实的MAC地址)。

##### ARP攻击方式

- ###### 简单的诈骗攻击

这是对比多见的攻击，经过发送伪造的ARP包来诈骗路由和方针主机，让方针主机认为这是一个合法的主机，便完成了诈骗，这种诈骗多发生在同一网段内，因为路由不会把本网段的包向外转发，当然完成不一样网段的攻击也有办法，便要经过ICMP协议来告诉路由器从头挑选路由。

- ###### 根据ARP的DOS

这是新呈现的一种攻击办法，D.O.S又称拒绝服务攻击，当大量的衔接请求被发送到一台主机时，因为主机的处理才能有限，不能为正常用户提供服务，便呈现拒绝服务。这个过程中假如运用ARP来躲藏自己，在被攻击主机的日志上就不会呈现真实的IP攻击，也不会影响到本机。

- ###### MAC Flooding

这是一个对比风险的攻击，能够溢出交流机的ARP表，使全部网络不能正常通讯。

- ###### 交流环境的嗅探

在开始的小型局域网中咱们运用HUB来进行互连，这是一种广播的办法，每个包都会经过网内的每台主机，经过运用软件，就能够嗅谈到全部局域网的数据。现在的网络多是交流环境，网络内数据的传输被锁定的特定方针。既已断定的方针通讯主机，在ARP诈骗的根底之上，能够把自己的主机伪形成一个中心转发站来监听两台主机之间的通讯。

##### ARP攻击的防护

- ARP 高速缓存超时设置

  在ARP高速缓存中的表项一般都要设置超时值，缩短这个这个超时值能够有用的避免ARP表的溢出。

- IP+MAC访问操控   -----推荐使用

  单纯依托IP或MAC来树立信赖联系是不安全，抱负的安全联系树立在IP+MAC的根底上，这也是咱们校园网上网有必要绑定IP和MAC的因素之一。

- 静态ARP缓存表

  每台主机都有一个暂时寄存IP-MAC的对应表ARP攻击就经过更改这个缓存来到达诈骗的意图，运用静态的ARP来绑定正确的MAC是一个有用的办法，在命令行下运用arp -a能够检查当时的ARP缓存表。

- 自动查询

  在某个正常的时间，做一个IP和MAC对应的数据库，以后定时检查当时的IP和MAC对应联系是否正常，定时检查交流机的流量列表，检查丢包率。

### IP协议栈

#### IP地址

##### 组成

IP 地址由**网络号**（网段地址）和**主机号**（主机地址）两部分组成。

![image-20230209130442767](../assets/image-20230209130442767.png)

**网络号**是设备所在区域的一种标识，网络号相同的设备位于同一个网段内，网络号不同的设备通过路由器实现通信。**主机号**是在同一个网段中不同设备的标识，不允许同一个网段内出现重复的主机号。

> IP地址配置举例

![image-20230209130531826](../assets/image-20230209130531826.png)

> 路由器转发原理

路由器是根据目的IP地址的网络号进行路由。

![image-20230209130830448](../assets/image-20230209130830448.png)

##### 分类

IP地址分为四类，A、B、C、D（还有一个保留的E类）

![image-20230209131005144](../assets/image-20230209131005144.png)

> A类

![image-20230209131047471](../assets/image-20230209131047471.png)

> B类

![image-20230209131108203](../assets/image-20230209131108203.png)

> C类

![image-20230209131318942](../assets/image-20230209131318942.png)

> D类

D 类 IP 地址是前四位以“ 1110 ”开头的地址。从第 1 位到第 32 位是它的网络号，网络号的范围是 `224.0.0.0 ~ 239.255.255.255` 。D 类地址没有主机号，用于**组播**。

> 例子

当主机号全为 0 时，表示的是**网段地址**，非主机地址。当主机号全为 1 时是**广播地址**，也不是主机地址。因此在分配 IP 地址过程中，需要**排除**这两个地址。例如一个 C 类地址 `192.168.1.0/24` 最多只有 254 个可用主机地址，而不是 256 个。

![image-20230209132216193](../assets/image-20230209132216193.png)

##### 广播地址

IP 地址中的主机号全部为 1 的就是**广播地址**，它是向同一个网段中的所有主机发送数据包。例如一个 B 类主机地址 `172.20.1.100` 的广播地址是 `172.20.255.255` 。

![image-20230209132409407](../assets/image-20230209132409407.png)

##### IP组播

**组播**用于将包发送给特定组内的所有主机。

![image-20230209133217875](../assets/image-20230209133217875.png)

组播使用 **D 类地址**。因此 IP 地址前四位是“ 1110 ”开头的，就是组播地址。剩下的 28 位就是组播的组编号。组播的地址范围是 `224.0.0.0 ~ 239.255.255.255` ，其中 `224.0.0.0 ~ 224.0.0.255` 既可以在同一个网段内实现组播，又可以跨网段给全网所有组员发送组播包。

##### 子网掩码

早期网络地址采用固定网络位长度的方式，使 IPv4 地址遭到大量浪费。如今网段地址的长度可变，同时也需要一种标识来获取网段地址，以便路由器对数据包进行转发，这种识别码就是**子网掩码**。

子网掩码用 32 位的二进制表示， IP 地址的网段地址部分设置为 1 ， IP 地址的主机地址部分设置为 0 。换句话说， IP 地址有多少位网段地址，子网掩码就有多少位取 1 ，其余都取 0 。为了方便记录，每 8 位为一组，以“ . ”隔开，再转换为十进制数。

例如：`201.20.100.25` 的子网掩码是 `255.255.255.0` ，算出它的网段地址。

![image-20230209133736825](../assets/image-20230209133736825.png)

![image-20230209133812309](../assets/image-20230209133812309.png)

##### CIDR与VLSM

**CIDR** ，即无类域间路由，采用任意长度分割 IP 地址的网络号和主机号。它有两个作用：

- 把多个网段聚合到一起，生成一个更大的网段；
- 汇总路由表 IP 地址，分担路由表压力。

![image-20230209134557704](../assets/image-20230209134557704.png)

**VLSM** ，即可变长子网掩码，它可以对 A 、 B 、 C 类地址再进行子网划分，以达到充分利用 IP 地址的目的。

假如一家企业有 100 台电脑，按以前的办法，只能分配一个 C 类地址 `222.222.222.0` 。但是 VLSM 可以在一个 C 类地址上划分出多个子网地址，再分配其中一个容纳主机数量与稍大于企业需求数量的子网地址给企业，这样就可以实现 IP 地址的合理使用。

- 计算容纳 100 台电脑的子网：使用主机号的位数计算出子网的主机地址数量。当主机号有 7 位时，有 126 个可用主机地址，可容纳 100 台电脑。

计算子网容量

- 计算子网地址：当主机号有 7 位时，网络号有 32 - 7 = 25 位，也就是 `222.222.222.0/24` 向主机位借了一位作为子网位，那么子网掩码也就是 `255.255.255.128` 。可分配 `222.222.222.0/25` 使用。

![image-20230209134815343](../assets/image-20230209134815343.png)

子网地址划分

- `222.222.222.0/25`子网详情：

![image-20230209134932131](../assets/image-20230209134932131.png)

![image-20230209134941376](../assets/image-20230209134941376.png)

> CIDR与VLSM区别

CIDR 是主机号**向网络号借位**，目的是把几个网络汇总成一个大的网络，增加子网主机数量；

VLSM 是网络号**向主机号借位**，目的是把一个标准的网络划分成几个子网，减少子网主机数量。

##### **公网地址与私有地址**

IP 地址分为**公网地址**和私有地址。公网地址是在互联网上使用的，私有地址是在局域网中使用的。

**公网地址**由 Internet NIC 负责分配，通过它直接访问互联网。

**私有地址**是一段保留的 IP 地址。只在局域网中使用，无法在互联网上使用。但是私有地址可以通过 NAT 技术，将私有地址转换为公网地址接入互联网。

![image-20230209135351463](../assets/image-20230209135351463.png)

#### IP路由

**IP 路由**是设备根据 IP 地址对数据进行转发的操作。当一个数据包到达路由器时，路由器根据数据包的目的地址查询路由表，根据查询结果将数据包转发出去，这个过程就是 IP 路由。

![image-20230209135637438](../assets/image-20230209135637438.png)

> 路由控制

为了将数据包发给目的节点，所有节点都维护着一张路由表。**路由表**记录 IP 数据在下一跳应该发给哪个路由器。IP 包将根据这个路由表在各个数据链路上传输。

![image-20230209142928205](../assets/image-20230209142928205.png)

### ICMP协议栈

ICMP 的全称是 `Internet Control Message Protocol(互联网控制协议)`，它是一种互联网套件，它用于**IP 协议中发送控制消息**。也就是说，ICMP 是依靠 IP 协议来完成信息发送的，它是 IP 的主要部分，但是从体系结构上来讲，它位于 IP 之上，因为 ICMP 报文是承载在 IP 分组中的，就和 TCP 与 UDP 报文段作为 IP 有效载荷被承载那样。这也就是说，当主机收到一个指明上层协议为 ICMP 的 IP 数据报时，它会分解出该数据报的内容给 ICMP，就像分解数据报的内容给 TCP 和 UDP 一样。

ICMP 协议和 TCP、UDP 等协议不同，它不用于传输数据，只是用来发送消息。因为 IP 协议现在有两类版本：IPv4 和 IPv6 ，所以 ICMP 也有两个版本：**ICMPv4 和 ICMPv6**。

#### ICMP的主要功能

对于 ICMP 的功能，主要分为两个

- ICMP 的第一个功能是**确认 IP 包是否能够成功到达目标地址**，当两个设备通过互联网相连时，任意一个设备发送给另一个设备的 IP 包如果没有到达，就会生成 ICMP 数据包发送给设备共享。
- ICMP 的第二个功能是进行`网络诊断`，经常使用 ICMP 数据包的两个终端程序是 `ping` 和 `traceroute`，traceroute 程序用于显示两台互联网设备之间可能的路径并测量数据包在 IP 网络上的时延。ping 程序是 traceroute 的简化版本，我们经常使用 ping 命令来测试两台设备之间是否互联，ping 通常用来测试两台主机之间的连接速度，并准确报告数据包到达目的地并返回后所花费的时间。

现在我们知道了，如果在 IP 通信过程中由于某个 IP 包由于某种原因未能到达目标主机，那么这个具体的原因将由 ICMP 进行通知，下面是一个 ICMP 的通知示意图

![image-20230219184835414](../assets/image-20230219184835414.png)

上面我们只是画出了路由器 2 给主机 A 发送了一个 ICMP 数据包，而没有画出具体的通知类型，但实际情况是，上面发送的是`目标不可达类型(Destination unreachable)`，ICMP 也是具有不同的通知类型的，下面我们汇总了 ICMP 数据包的具体通知类型。

| 通知类型(十进制数) | 具体内容                            |
| :----------------- | :---------------------------------- |
| 0                  | 回送应答(Echo Reply)                |
| 3                  | 目标不可达(Destination Unreachable) |
| 4                  | 原点抑制(Source Quench)             |
| 5                  | 重定向或改变路由(Redirect)          |
| 8                  | 回送请求(Echo Request)              |
| 9                  | 路由器公告(Router Advertisement)    |
| 10                 | 路由器请求(Router Solicitation)     |
| 11                 | ICMP 超时(Time Exceeded)            |
| 17                 | 地址子网请求(Address Mask Request)  |
| 18                 | 地址子网应答(Address Mask Reply)    |

上表显示的 ICMP 通知类型主要分为两类：有关 IP 数据报传递的 ICMP 报文，这类报文也叫做`差错报文(error message)`，以及有关信息采集和配置的 ICMP 报文，这类报文也被称为查询 query 或者信息类报文。

信息类报文包括回送请求和回送应答(类型 8 和 类型 0 )，路由器公告和路由器请求(类型 9 和 类型 0 )。最常见的差错报文类型包括目标不可达(类型 3 )、重定向(类型 5)、超时(类型 11)。

#### ICMP在IPv4和IPv6的封装

![image-20230219185006310](../assets/image-20230219185006310.png)

![image-20230219185014062](../assets/image-20230219185014062.png)

> ICMP头部包含了ICMP数据段的校验和，具体如下。

![image-20230219185031959](../assets/image-20230219185031959.png)

所有的 ICMP 报文都以 8 位的`类型(Type)` 和`代码(Code)` 字段开始，其后的 `16 位`校验和涵盖了整个报文，ICMPv4 和 ICMPv6 种的类型和代码字段是不同的。

#### ICMP的主要信息

##### ICMP目标不可达（类型3）

我们知道，路由器无法将 IP 数据报发送给目标地址时，会给发送端主机返回一个`目标不可达(Destination Unreachable Message)` 的 ICMP 消息，并且会在消息中显示不可达的具体原因。

![image-20230219190244562](../assets/image-20230219190244562.png)

实际通信过程中会显示各种各样的不可达信息，比如错误代码时 1 表示主机不可达，它指的是路由表中没有主机的信息，或者主机没有连接到网络的意思。一些 ICMP 不可达信息的具体原因如下

| 错误号 | ICMP 不可达消息                                              |
| :----- | :----------------------------------------------------------- |
| 0      | 0 = net unreachable 网络不可达                               |
| 1      | 1 = host unreachable 主机不可达                              |
| 2      | 2 = protocol unreachable 协议不可达                          |
| 3      | 3 = port unreachable 端口不可达                              |
| 4      | 4 = fragmentation needed and DF set 需要进行分片但设置不分片比特 |
| 5      | 5 = source route failed 源站选路失败                         |
| 6      | 6 = Destination network unknown 目的网络不认识               |
| 7      | 7 = Destination host unknown 目的主机不认识                  |
| 8      | 8 = Source host isolated (obsolete)源主机被隔离（作废不用）  |
| 9      | 9 = Destination network administratively prohibited 目的网络被强制禁止 |
| 10     | 10 = Destination host administratively prohibited目的主机被强制禁止 |
| 11     | 11 = Network unreachable for Type Of Service 由于 TOS，网络不可达 |
| 12     | 12 = Host unreachable for Type Of Service 由于 TOS，主机不可达 |

##### ICMP重定向消息（类型5）

如果路由器发现发送端主机使用了次优的路径发送数据，那么它会返回一个 `ICMP 重定向(ICMP Redirect Message)` 的消息给这个主机。这个 ICMP 重定向消息包含了最合适的**路由信息和源数据**。这种情况会发生在路由器持有更好的路由信息的情况下。路由器会通过这样的 ICMP 消息给发送端主机一个更合适的发送路由

![image-20230219190558106](../assets/image-20230219190558106.png)

主机 Host 的 IP 地址为 10.0.0.100。主机的路由表中有一个默认路由条目，指向路由器 G1 的 IP 地址 10.0.0.1 作为默认网关。路由器 G1 在将数据包转发到目的网络 X 时，会使用路由器 G2 的 IP 地址 10.0.0.2 作为下一跳。

当主机向目的网络 X 发送数据包时，会发生以下情况

1. IP 地址为 10.0.0.1 的网关 G1 在其所连接的网络上接收来自 10.0.0.100 的数据包。
2. 网关 G1 检查其路由表，并在通往数据包目的网络 X 的路由中获取下一个网关 G2 的 IP 地址 10.0.0.2。
3. 如果 G2 和 IP 数据包的源地址标识的主机位于同一网络中(也就是 Host 主机)，那么 G1 会向主机发送 ICMP 重定向消息。ICMP 重定向消息建议主机直接将发送到网络 X 的数据包发送至 G2，因为 Host - G2 这是通往目的地的较短路径。
4. 网关 G1 将原始数据包转发到其目的地。

当然，根据主机的配置，Host 主机也可以选择忽略 G1 给它发送的 ICMP 重定向消息。但是，这样就享受不到 ICMP 重定向带来的两大好处，即

- 优化数据在网络中的转发路径；流量更快到达目的地
- 降低网络资源利用率，例如带宽和路由器 CPU 负载

如果 Host 主机采用了 ICMP 提供的重定向路径的话，那么 Host 就会直接把数据包发送至网络 X，如下图所示

![image-20230219190629469](../assets/image-20230219190629469.png)

在主机为 G2 作为下一跳的网络 X 创建路由缓存条目后，这些优势在网络中可见：

- 交换机和路由器 G1 之间链路的带宽利用率在两个方向上都会降低
- 由于从主机到网络 X 的流量不再流经此节点，因此路由器 G1 的 CPU 使用率降低
- 主机和网络 X 之间的端到端网络延迟得到改善。

ICMP重定向示例如下

![image-20230219190758598](../assets/image-20230219190758598.png)

##### ICMP超时消息（类型11）

在 IP 数据包中有一个叫做 `TTL(Time To Live, 生存周期)` ，它的值在每经过路由器一跳之后都会减 1，IP 数据包减为 0 时会被丢弃。此时，IP 路由器会发送一个 ICMP 超时消息(ICMP TIme Exceeded Message, 错误号 0)发送给主机，通知该包已经被丢弃。

设置生存周期的主要目的就是为了防止路由器控制遇到问题发生循环状况时，避免 IP 包无休止的在网络上转发，如下图所示

![image-20230219190828521](../assets/image-20230219190828521.png)

##### ICMP回送消息（类型0和类型8）

ICMP 回送消息用于判断相互通信的主机之间是否连通，也就是判断所发送的数据包是否能够到达目标主机。可以向对端主机发送`回送请求的消息(ICMP Echo Request Message,类型 8)`，也可以接收对端主机发送来的回送消息(ICMP Echo Reply Message, 类型 0 )。网络上最常用的 ping 命令就是利用这个实现的。

![image-20230219190858654](../assets/image-20230219190858654.png)

#### 其他ICMP消息

##### ICMP原点抑制消息（类型4）

在使用低速率网络的情况下，网络通信可能会遇到网络拥堵的情况下，ICMP 的原点抑制就是为了应对这种情况的。当路由器向低速线路发送数据时，其发送队列的残存数据报变为 0 从而无法发送时，可以向 IP 数据报的源地址发送一个 `ICMP 原点抑制(ICMP Source Quench Message)` 消息，收到这个消息的主机了解到线路某处发生了拥堵，从而抑制 IP 数据报的发送。

![image-20230219190930892](../assets/image-20230219190930892.png)

##### ICMP路由器探索消息（类型9、10）

ICMP 路由器探索消息主要用于`路由器发现(Router Discovery, RD)`，它主要分为两种，`路由器请求(Router Solicitation, 类型 10)` 和`路由器响应(Router Advertisement, 类型 9)`。主机会在任意路由连接组播的网络上发送一个 RS 消息，想要选择一个路由器进行学习，以此来作为默认路由，而相对应的该路由会发送一个 RA 消息来作为默认路由的响应。

![image-20230219191006381](../assets/image-20230219191006381.png)

##### ICMP地址掩码消息（类型17、18）

主要用于主机或者路由器想要了解子网掩码的情况。可以向那些目标主机或路由器发送 `ICMP 地址掩码请求消息(ICMP Address Mask Request, 类型 17)` 和 `ICMP 地址掩码应答消息(ICMP Address Mask Reply, 类型 18)` 获取子网掩码信息。

#### ICMPv6

##### ICMPv6的作用

IPv4 中 ICMP 仅仅作为一个辅助作用支持 IPv4。也就是说，在 IPv4 时期，即使没有 ICMP，也能进行正常的 IP 数据包的发送和接收，也就是 IP 通信。但是在 IPv6 中，ICMP 的作用被放大了，如果没有 ICMP，则不能进行正常的 IP 通信。

尤其在 IPv6 中，从 IP 定位 MAC 地址的协议从 ARP 转为 ICMP 的`邻居探索消息(Neighbor Discovery)` 。这种邻居探索消息融合了 IPv4 的 ARP、ICMP 重定向以及 ICMP 的路由选择等功能于一体。甚至还提供了自动设置 IP 的功能。

在 IPv6 中，ICMP 消息主要分为两类：一类是`错误消息`，一类是`信息消息`。0 - 127 属于错误消息；128 - 255 属于信息消息。

| 类型 | 描述                                                        |
| :--- | :---------------------------------------------------------- |
| 1    | 目标不可达 Destination Unreachable                          |
| 2    | 数据包太大 Packet Too Big                                   |
| 3    | 超时 Time Exceeded                                          |
| 4    | 参数问题 Parameter Problem                                  |
| 128  | 回送请求消息 Echo Request                                   |
| 129  | 回送应答消息 Echo Reply                                     |
| 130  | 多播监听查询 Multicast Listener Query                       |
| 131  | 多播监听报告 Multicast Listener Report                      |
| 132  | 多播监听结束 Multicast Listener Done                        |
| 133  | 路由器请求消息 Router Solicitation                          |
| 134  | 路由器公告消息 Router Advertisement                         |
| 135  | 邻居请求消息 Neighbor Solicitation                          |
| 136  | 邻居宣告消息 Neighbor Advertisement                         |
| 137  | 重定向消息 Redirect Message                                 |
| 138  | 路由器重编号 Router Renumbering                             |
| 139  | 信息查询 ICMP Node Information Query                        |
| 140  | 信息应答 ICMP Node Information Response                     |
| 141  | 反邻居探索请求消息 Inverse Neighbor Discovery Solicitation  |
| 142  | 反邻居探索宣告消息 Inverse Neighbor Discovery Advertisement |

##### ICMPv6邻居探索

邻居探索是 ICMPv6 非常重要的功能，主要表示的类型是 133 - 137 之间的消息叫做`邻居探索消息`。这种邻居探索消息对于 IPv6 通信起到举足轻重的作用。邻居请求消息用于查询 IPv6 地址于 MAC 地址的对应关系。邻居请求消息利用 IPv6 的多播地址实现传输。

![image-20230219191141172](../assets/image-20230219191141172.png)

此外，由于 IPv6 实现了即插即用的功能，所以在没有 `DHCP` 服务器的环境下也能实现 IP 地址的自动获取。如果是一个没有路由器的网络，就使用 MAC 地址作为链路本地单播地址。如果在一个有路由器的网络环境中，可以从路由器获得 IPv6 地址的前面部分，后面部分使用 MAC 地址进行设置。此时可以利用路由器请求消息和路由器公告消息进行设置。

![image-20230219191207113](../assets/image-20230219191207113.png)

##### ICMPv6的组播收听发现协议

`组播收听发现协议（MLD，Multicast Listener Discovery）`由子网内的组播成员管理。MLD 协议定义了3条ICMPv6 消息：

- 组播收听查询消息：组播路由器向子网内的组播收听者发送此消息，以获取组播收听者的状态。
- 组播收听者报告消息：组播收听者向组播路由器汇报当前状态，包括离开某个组播组。
- 组播收听者。

#### 与ICMP有关的攻击

涉及 ICMP 攻击主要分为 3 类：**泛洪(flood)、炸弹(bomb) 和信息泄露(information disclsure)**。

- 泛洪将会产生大量流量，导致针对一台或者多台计算机的有效 Dos 攻击。
- 炸弹指的是发送经过特殊构造的报文，这类报文能够导致 IP 或者 ICMP 的处理失效或者崩溃。
- 信息泄露本身不会造成危害，但是能够帮助辅助其他攻击。

针对 TCP 的 ICMP 攻击已经记录在了 RFC5927 中。

### TCP/UDP协议栈

#### TCP/IP基础

##### TCP/IP的具体含义

从字面意义上讲，有人可能会认为 TCP/IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称。具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP/IP 协议。他们与 TCP 或 IP 的关系紧密，是互联网必不可少的组成部分。TCP/IP 一词泛指这些协议，因此，有时也称 TCP/IP 为网际协议群。互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议。

![image-20230220111433577](../assets/image-20230220111433577.png)

##### 数据包

**包、帧、数据包、段、消息**以上五个术语都用来表述数据的单位，大致区分如下：

- 包可以说是全能性术语；
- 帧用于表示数据链路层中包的单位；
- 数据包是 IP 和 UDP 等网络层以上的分层中包的单位；
- 段则表示 TCP 数据流中的信息；
- 消息是指应用协议中数据的单位。

每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。

![image-20230220111458540](../assets/image-20230220111458540.png)

网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上一层传过来的数据。首部的结构由协议的具体规范详细定义。在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息以及所要处理的数据。**包首部就像协议的脸。**

##### 数据处理流程

下图以用户 a 向用户 b 发送邮件为例子：

![image-20230220111641451](../assets/image-20230220111641451.png)



- ① 应用程序处理 首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能；编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层功能。
- ② TCP 模块的处理 TCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。
- ③ IP 模块的处理 IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。
- ④ 网络接口（以太网驱动）的处理 从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。
- ⑤ 网络接口（以太网驱动）的处理 主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。
- ⑥ IP 模块的处理 IP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。另外吗，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。
- ⑦ TCP 模块的处理 在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。
- ⑧ 应用程序的处理 接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。

#### TCP/UDP

TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。

- TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。
- UDP 是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。
- TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP 应该根据应用的目的按需使用。

##### 端口号

数据链路和 IP 中的地址，分别指的是 MAC 地址和 IP 地址。前者用来识别同一链路中不同的计算机，后者用来识别 TCP/IP  网络中互连的主机和路由器。在传输层也有这种类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。

###### 根据端口号识别应用

一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。

![image-20230220112058678](../assets/image-20230220112058678.png)

###### 通过IP地址、端口号、协议号进行通信识别

![image-20230220112125100](../assets/image-20230220112125100.png)

![image-20230220112138492](../assets/image-20230220112138492.png)

- ① 和② 的通信是在两台计算机上进行的。它们的目标端口号相同，都是80。这里可以根据源端口号加以区分。
- ③ 和 ① 的目标端口号和源端口号完全相同，但它们各自的源 IP 地址不同。
- 此外，当 IP 地址和端口号全都一样时，我们还可以通过协议号来区分（TCP 和 UDP）。

###### 端口号的确定

- 标准既定的端口号：这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。但并不是说可以随意使用任何一个端口号。例如 HTTP、FTP、TELNET 等广为使用的应用协议中所使用的端口号就是固定的。这些端口号被称为知名端口号，分布在 0~1023 之间；除知名端口号之外，还有一些端口号被正式注册，它们分布在 1024~49151 之间，不过这些端口号可用于任何通信用途。
- 时序分配法：服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号。在这种方法下，客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配。动态分配的端口号范围在 49152~65535 之间。

###### 端口号与协议

- 端口号由其使用的传输层协议决定。因此，不同的传输层协议可以使用相同的端口号。
- 此外，那些知名端口号与传输层协议并无关系。只要端口一致都将分配同一种应用程序进行处理。

#### UDP

- UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。
- 并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。
- 此外，传输途中出现丢包，UDP 也不负责重发。
- 甚至当包的到达顺序出现乱序时也没有纠正的功能。
- 如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理。
- UDP 常用于一下几个方面：1.包总量较少的通信（DNS、SNMP等）；2.视频、音频等多媒体通信（即时通信）；3.限定于 LAN 等特定网络中的应用通信；4.广播通信（广播、多播）。

#### TCP

- TCP 与 UDP 的区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。
- 此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。
- 根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）。

##### 三次握手

- TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。
- 所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。

![image-20230220122518796](../assets/image-20230220122518796.png)

- 第一次握手：客户端将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。
- 第二次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。
- 第三次握手：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。

##### 四次挥手

- 四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。
- 由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。

![image-20230220122549012](../assets/image-20230220122549012.png)

- 中断连接端可以是客户端，也可以是服务器端。
- 第一次挥手：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说"我客户端没有数据要发给你了"，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。
- 第二次挥手：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。
- 第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。
- 第四次挥手：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。

**上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况**具体流程如下图：

![image-20230220122606915](../assets/image-20230220122606915.png)

##### 通过序列号与确认应答提高可靠性

- 在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK）。当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。**反之，则数据丢失的可能性很大**。
- 在一定时间内没有等待到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输。
- 未收到确认应答并不意味着数据一定丢失。也有可能是数据对方已经收到，只是返回的确认应答在途中丢失。这种情况也会导致发送端误以为数据没有到达目的地而重发数据。
- 此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源主机只要按照机制重发数据即可。
- 对于目标主机来说，反复收到相同的数据是不可取的。为了对上层应用提供可靠的传输，目标主机必须放弃重复的数据包。为此我们引入了序列号。
- **序列号是按照顺序给发送数据的每一个字节（8位字节）都标上号码的编号。接收端查询接收数据 TCP 首部中的序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答返送回去。通过序列号和确认应答号，TCP 能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输。**

![image-20230220122640031](../assets/image-20230220122640031.png)

##### 重发超时的确定

- **重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔**。如果超过这个时间仍未收到确认应答，发送端将进行数据重发。最理想的是，找到一个最小时间，它能保证“确认应答一定能在这个时间内返回”。
- TCP 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间及其偏差。将这个往返时间和偏差时间相加，重发超时的时间就是比这个总和要稍大一点的值。
- 在 BSD 的 Unix 以及 Windows 系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍。不过，最初其重发超时的默认值一般设置为6秒左右。
- 数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。
- 此外，**数据也不会被无限、反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止**。

##### 以段为单位发送数据

- 在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们也可以称其为“最大消息长度”（MSS）。最理想的情况是，最大消息长度正好是 IP 中不会被分片处理的最[大数据](https://cloud.tencent.com/solution/bigdata?from=10680)长度。
- TCP 在传送大量数据时，是以 MSS 的大小将数据进行分割发送。进行重发时也是以 MSS  为单位。
- MSS 在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在 TCP 首部中写入 MSS  选项，告诉对方自己的接口能够适应的 MSS 的大小。然后会在两者之间选择一个较小的值投入使用。

##### 利用窗口控制提高速度

- TCP 以1个段为单位，每发送一个段进行一次确认应答的处理。这样的传输方式有一个缺点，就是包的往返时间越长通信性能就越低。
- 为解决这个问题，TCP 引入了窗口这个概念。确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅地缩短。也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送。如下图所示：

![image-20230220122733409](../assets/image-20230220122733409.png)

窗口大小就是指无需等待确认应答而可以继续发送数据的最大值。上图中窗口大小为4个段。这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能。

##### 滑动窗口控制

![image-20230220122757870](../assets/image-20230220122757870.png)

- 上图中的窗口内的数据即便没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此，发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答。
- 在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。
- 收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为滑动窗口控制。

##### 窗口控制中的重发控制

在使用窗口控制中， 出现丢包一般分为两种情况：

- ① 确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的，如下图：

![image-20230220122830422](../assets/image-20230220122830422.png)

- ② 某个报文段丢失的情况。接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答。如下图所示，当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答，就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为高速重发控制。![image-20230220122851663](../assets/image-20230220122851663.png)

### VLAN



### VxLAN





## NetWork Stack and Hand CNIs







## 额外知识

### 1、理解CNI和CNI插件

CNI是什么？

```markdown
* Container Network Interface,容器网络的API接口
* Kubelet通过这个标准的API调用不同的网络插件实现配置网络
* CNI插件：一系列实现了CNI API接口的网络插件
```

Kubernetes中如何使用CNI？

![image-20230207020357288](../assets/image-20230207020357288.png)

```markdown
* 配置CNI配置文件(/etc/cni/net.d/xxnet.conf)
* 安装CNI二进制插件(/opt/cni/bin/xxnet)
* 在这个节点上创建Pod
* Kubelet会根据CNI配置文件执行CNI插件
* Pod的网络就配置完成了
```

哪个CNI插件适合？

1. Overlay

   ![image-20230207020401057](../assets/image-20230207020401057.png)

   Overlay靠隧道打通，不依赖底层网络

   容器有独立于主机的ip段，在跨主机网络通信的时候，通过在每个主机间创建隧道的方式，把容器网段的包封装成物理网络之间的包。

2. 路由

   ![image-20230207020403278](../assets/image-20230207020403278.png)

   靠路由打通，部分依赖底层网络

   容器与主机是不同的网段，跨主机的网络是靠路由去做打通

3. Underlay

   ![image-20230207020405500](../assets/image-20230207020405500.png)

   靠底层网络能力打通，强依赖底层网络

   容器与宿主机是同一层网络，同样的网段，是依靠于底层网络打通。

![image-20230207020409063](../assets/image-20230207020409063.png)

如何开发自己的CNI插件？

```markdown
* 一个二进制的CNI插件去配置Pod的网卡和IP等 -> 给Pod插上网线
* 一个Daemon进程去管理Pod之间的网络打通   -> 给Pod连上网络
```

- 给Pod插上网线

  1. 给Pod准备虚拟网卡

     - 创建"veth"虚拟网卡对
     - 将一端的网卡挪到Pod中

     ![image-20230207020412572](../assets/image-20230207020412572.png)

  2. 给Pod分配IP地址

     - 给Pod分配集群中唯一的IP地址
     - 一般会把Pod网段按Node分段
     - 每个Pod再从Node段中分配IP

     ![image-20230207020417088](../assets/image-20230207020417088.png)

  3. 配置Pod的IP和路由

     - 给Pod的虚拟网卡配置分配到的IP
     - 给Pod的网卡上配置集群网段的路由
     - 在宿主机上配置到Pod的IP地址的路由到对端虚拟网卡上

- 给Pod连上网络：让每一个Pod的IP在集群中都能被访问到

  1. CNI Daemon进程学习到集群所有Pod的IP和其所在节点

     - 通常通过请求K8S APIServer拿到现有Pod的IP地址和节点
     - 监听K8S APIServer新的Node和Pod的创建自动配置

  2. CNI Daemon配置网络来打通Pod的IP的访问

     - 创建到所有Node的通道：

       Overlay隧道，VPC路由表，BGP路由等

     - 将所有Pod的IP地址跟其所在Node的通道关联起来

       Linux路由，Fdb转发表，OVS流表等

